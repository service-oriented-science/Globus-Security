From 6c9689ffdca23da53b393269f17ee235f3b94c13 Mon Sep 17 00:00:00 2001
From: Rachana Ananthakrishnan <ranantha@mcs.anl.gov>
Date: Wed, 2 Dec 2009 10:23:36 -0600
Subject: [PATCH 1/8] Rework X509Credential class to support clear or encrypted private key, and cert/file from separate streams.


Signed-off-by: Rachana Ananthakrishnan <ranantha@mcs.anl.gov>
---
 integration-example/src/main/resources/myKeystore  |    6 +-
 ssl-proxy/readme.txt                               |    7 +
 .../java/org/globus/security/X509Credential.java   |  142 ++++++++++++++------
 .../globus/security/bc/BouncyCastleOpenSSLKey.java |    6 +
 .../security/provider/FileBasedKeyStore.java       |   38 ++++-
 5 files changed, 148 insertions(+), 51 deletions(-)

diff --git a/integration-example/src/main/resources/myKeystore b/integration-example/src/main/resources/myKeystore
index 961ee1f..3f382bb 100644
--- a/integration-example/src/main/resources/myKeystore
+++ b/integration-example/src/main/resources/myKeystore
@@ -1,3 +1,7 @@
 # Properties file as input to the keystore (PEMFilebasedKeystore)
 # Name of proxy file
-proxyFilename=/Users/ranantha/work/sos/gitRepository/Globus-Security/integration-example/target/classes/proxy.pem
\ No newline at end of file
+#proxyFilename=/Users/ranantha/work/sos/gitRepository/Globus-Security/integration-example/target/classes/proxy.pem
+# Name of certificate file
+certificateFilename=/Users/ranantha/.globus/usercert.pem
+# Name of key file
+keyFilename=/Users/ranantha/.globus/userkey.pem
\ No newline at end of file
diff --git a/ssl-proxy/readme.txt b/ssl-proxy/readme.txt
index ce144e4..6a711ec 100644
--- a/ssl-proxy/readme.txt
+++ b/ssl-proxy/readme.txt
@@ -4,3 +4,10 @@ To do:
 * Test coverage for proxy credential handling classes from CoG
 * Improve test coverage for keystore impl.
 * Look at CoG patches since 1.7.0 was released and merge those features
+
+For documentation:
+==================
+
+* The following error message from SSL handshake could also mean that the credentials were empty or no credentials were
+ presented for handshake. "javax.net.ssl.SSLException: No available certificate or key corresponds to the SSL cipher
+ suites which are enabled."
diff --git a/ssl-proxy/src/main/java/org/globus/security/X509Credential.java b/ssl-proxy/src/main/java/org/globus/security/X509Credential.java
index 59a9f40..12e78ff 100644
--- a/ssl-proxy/src/main/java/org/globus/security/X509Credential.java
+++ b/ssl-proxy/src/main/java/org/globus/security/X509Credential.java
@@ -33,7 +33,6 @@ import java.util.Date;
 import java.util.Vector;
 
 import org.globus.security.bc.BouncyCastleOpenSSLKey;
-import org.globus.security.filestore.FileBasedSigningPolicyStore;
 import org.globus.security.util.CertificateIOUtil;
 import org.globus.security.util.CertificateLoadUtil;
 
@@ -45,16 +44,15 @@ import org.slf4j.LoggerFactory;
  * FILL ME
  * <p/>
  * This class equivalent was called GlobusCredential in CoG -maybe a better name?
- * FIXME: add support for encrypted keys.
  *
  * @author ranantha@mcs.anl.gov
  */
 public class X509Credential {
 
     private static Logger logger =
-            LoggerFactory.getLogger(FileBasedSigningPolicyStore.class.getName());
+            LoggerFactory.getLogger(X509Credential.class.getName());
 
-    private PrivateKey key;
+    private OpenSSLKey opensslKey;
     private X509Certificate[] certChain;
 
     public X509Credential(PrivateKey key_, X509Certificate[] certChain_) {
@@ -70,31 +68,57 @@ public class X509Credential {
         }
 
         this.certChain = certChain_;
-        this.key = key_;
+        this.opensslKey = new BouncyCastleOpenSSLKey(key_);
     }
 
     public X509Credential(InputStream stream) throws CredentialException {
-        loadCredential(stream);
+
+        this(stream, stream);
+    }
+
+    public X509Credential(InputStream certInputStream, InputStream keyInputStream)
+            throws CredentialException {
+
+        loadKey(keyInputStream);
+        loadCertificate(certInputStream);
+        validateCredential();
     }
 
     public X509Certificate[] getCertificateChain() {
         return this.certChain;
     }
 
-    public Key getPrivateKey() {
-        return this.key;
+    public Key getPrivateKey() throws CredentialException {
+
+        return getPrivateKey(null);
     }
 
-    protected void loadCredential(InputStream input)
+    public Key getPrivateKey(String password) throws CredentialException {
+
+        if (this.opensslKey.isEncrypted()) {
+            if (password == null) {
+                throw new CredentialException("Key encrypted, password required");
+            } else {
+                try {
+                    this.opensslKey.decrypt(password);
+                } catch (GeneralSecurityException exp) {
+                    throw new CredentialException(exp.getMessage(), exp);
+                }
+            }
+        }
+        return this.opensslKey.getPrivateKey();
+
+    }
+
+    protected void loadCertificate(InputStream input)
             throws CredentialException {
 
         if (input == null) {
             throw new IllegalArgumentException(
-                    "Inputstream to load X509Credential is null");
+                    "Input stream to load X509Credential is null");
         }
 
-        PrivateKey key = null;
-        X509Certificate cert = null;
+        X509Certificate cert;
         Vector chain = new Vector();
 
         String line;
@@ -110,14 +134,6 @@ public class X509Credential {
                     cert = CertificateLoadUtil
                             .loadCertificate(new ByteArrayInputStream(data));
                     chain.addElement(cert);
-                } else if (line.indexOf("BEGIN RSA PRIVATE KEY") != -1) {
-                    byte[] data = getDecodedPEMObject(reader);
-                    // FIXME: BC seems to have some PEM utility but the actual
-                    // load is in private methods and cannot be leveraged.
-                    // Investigate availability of standard libraries for these
-                    // low level reads. FOr now, copying from CoG
-                    OpenSSLKey k = new BouncyCastleOpenSSLKey("RSA", data);
-                    key = k.getPrivateKey();
                 }
             }
 
@@ -135,21 +151,41 @@ public class X509Credential {
         }
 
         int size = chain.size();
+        if (size > 0) {
+            // set chain
+            this.certChain = new X509Certificate[size];
+            chain.copyInto(this.certChain);
+        }
+
+    }
+
+    protected void loadKey(InputStream input) throws CredentialException {
+
+        // FIXME: BC seems to have some PEM utility but the actual
+        // load is in private methods and cannot be leveraged.
+        // Investigate availability of standard libraries for these
+        // low level reads. FOr now, copying from CoG
+
+        try {
+            this.opensslKey = new BouncyCastleOpenSSLKey(input);
+        } catch (IOException e) {
+            throw new CredentialException(e.getMessage(), e);
+        } catch (GeneralSecurityException e) {
+            throw new CredentialException(e.getMessage(), e);
+        }
+    }
+
+    private void validateCredential() throws CredentialException {
+
+        int size = this.certChain.length;
 
-        if (size == 0) {
+        if (size < 0) {
             throw new CredentialException("No certificates found.");
         }
 
-        if (key == null) {
+        if (this.opensslKey == null) {
             throw new CredentialException("NO private key found");
         }
-
-        // set chain
-        this.certChain = new X509Certificate[size];
-        chain.copyInto(this.certChain);
-
-        // set key
-        this.key = key;
     }
 
     /**
@@ -170,17 +206,19 @@ public class X509Credential {
         throw new EOFException("Missing PEM end footer");
     }
 
-    public void save(OutputStream out)
+    public void saveKey(OutputStream out) throws IOException {
+
+        this.opensslKey.writeTo(out);
+        out.flush();
+    }
+
+    public void saveCertificateChain(OutputStream out)
             throws IOException, CertificateEncodingException {
 
         CertificateIOUtil.writeCertificate(out, this.certChain[0]);
 
-        OpenSSLKey k = new BouncyCastleOpenSSLKey(key);
-        k.writeTo(out);
-
         for (int i = 1; i < this.certChain.length; i++) {
-            // FIXME: should we?
-            // this will skip the self-signed certificates
+            // FIXME: should we skip the self-signed certificates?
             if (this.certChain[i].getSubjectDN().equals(certChain[i].getIssuerDN())) continue;
             CertificateIOUtil.writeCertificate(out, this.certChain[i]);
         }
@@ -188,24 +226,44 @@ public class X509Credential {
         out.flush();
     }
 
+    public void save(OutputStream out) throws IOException, CertificateEncodingException {
+        saveKey(out);
+        saveCertificateChain(out);
+    }
+
     public void writeToFile(File file) throws IOException, CertificateEncodingException {
-        FileOutputStream outputStream = new FileOutputStream(file);
+        writeToFile(file, file);
+    }
+
+    public void writeToFile(File certFile, File keyFile) throws IOException, CertificateEncodingException {
+
+        FileOutputStream keyOutputStream = new FileOutputStream(keyFile);
+        FileOutputStream certOutputStream = new FileOutputStream(certFile);
         try {
-            save(outputStream);
+            saveKey(keyOutputStream);
+            saveCertificateChain(certOutputStream);
         } finally {
-            if (outputStream != null) {
+            if (keyOutputStream != null) {
                 try {
-                    outputStream.close();
+                    keyOutputStream.close();
                 } catch (IOException e) {
-                    logger.warn("Could not close stream on save to file.");
+                    logger.warn("Could not close stream on save of key to file. " + keyFile.getPath());
+                }
+            }
+            if (certOutputStream != null) {
+                try {
+                    certOutputStream.close();
+                } catch (IOException e) {
+                    logger.warn("Could not close stream on save certificate chain to file. " + certFile.getPath());
                 }
             }
         }
     }
 
     public Date getNotBefore() {
-        // FILL ME
-        return new Date();
+
+        // FIXME
+        return null;
     }
 
 }
diff --git a/ssl-proxy/src/main/java/org/globus/security/bc/BouncyCastleOpenSSLKey.java b/ssl-proxy/src/main/java/org/globus/security/bc/BouncyCastleOpenSSLKey.java
index b0696c3..49beac2 100644
--- a/ssl-proxy/src/main/java/org/globus/security/bc/BouncyCastleOpenSSLKey.java
+++ b/ssl-proxy/src/main/java/org/globus/security/bc/BouncyCastleOpenSSLKey.java
@@ -21,6 +21,7 @@ import java.io.InputStream;
 import java.security.GeneralSecurityException;
 import java.security.KeyFactory;
 import java.security.PrivateKey;
+import java.security.Security;
 import java.security.interfaces.RSAPrivateCrtKey;
 import java.security.spec.PKCS8EncodedKeySpec;
 
@@ -34,12 +35,17 @@ import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
 import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
 import org.bouncycastle.asn1.pkcs.RSAPrivateKeyStructure;
 import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
+import org.bouncycastle.jce.provider.BouncyCastleProvider;
 
 /**
  * BouncyCastle-based implementation of OpenSSLKey.
  */
 public class BouncyCastleOpenSSLKey extends OpenSSLKey {
 
+    static {
+        Security.addProvider(new BouncyCastleProvider());
+    }
+
     public BouncyCastleOpenSSLKey(InputStream is)
             throws IOException, GeneralSecurityException {
         super(is);
diff --git a/ssl-proxy/src/main/java/org/globus/security/provider/FileBasedKeyStore.java b/ssl-proxy/src/main/java/org/globus/security/provider/FileBasedKeyStore.java
index d2e663a..ea08e92 100644
--- a/ssl-proxy/src/main/java/org/globus/security/provider/FileBasedKeyStore.java
+++ b/ssl-proxy/src/main/java/org/globus/security/provider/FileBasedKeyStore.java
@@ -24,6 +24,7 @@ import java.util.Hashtable;
 import java.util.Map;
 import java.util.Properties;
 
+import org.globus.security.CredentialException;
 import org.globus.security.X509Credential;
 import org.globus.security.filestore.FileBasedKeyStoreParameters;
 import org.globus.security.filestore.FileBasedObject;
@@ -217,15 +218,17 @@ public class FileBasedKeyStore extends KeyStoreSpi {
             loadDirectories(new String[]{params.getDefaultCertDir()});
             // load proxy certificate, if configured
             loadProxyCertificate(params.getProxyFilename());
+
+            // load usercert/key, if configured
+            loadCertificateKey(params.getUserCertFilename(),
+                    params.getUserKeyFilename(),
+                    params.getProtectionParameter());
+
         } catch (FileStoreException e) {
             throw new CertificateException(e);
+        } catch (CredentialException e) {
+            throw new CertificateException(e);
         }
-
-
-        // load usercert/key, if configured
-        loadCertificateKey(params.getUserCertFilename(),
-                params.getUserKeyFilename(),
-                params.getProtectionParameter());
     }
 
     @Override
@@ -279,6 +282,9 @@ public class FileBasedKeyStore extends KeyStoreSpi {
                 }
             } catch (FileStoreException e) {
                 throw new CertificateException(e);
+            } catch (CredentialException e) {
+                e.printStackTrace();
+                throw new CertificateException(e);
             }
         } finally {
             try {
@@ -292,6 +298,10 @@ public class FileBasedKeyStore extends KeyStoreSpi {
 
     private void loadProxyCertificate(String proxyFilename) throws FileStoreException {
 
+        if (proxyFilename == null) {
+            return;
+        }
+
         proxyDelegate.loadWrappers(new String[]{proxyFilename});
         Map<String, FileBasedProxyCredential> wrapperMap =
                 proxyDelegate.getWrapperMap();
@@ -302,8 +312,20 @@ public class FileBasedKeyStore extends KeyStoreSpi {
 
 
     private void loadCertificateKey(String userCertFilename, String userKeyFilename,
-                                    KeyStore.ProtectionParameter protectionParameter) {
-        //TODO: implement me.
+                                    KeyStore.ProtectionParameter protectionParameter)
+            throws CredentialException {
+
+        if ((userCertFilename == null) ||
+                (userKeyFilename == null)) {
+            return;
+        }
+
+        String password = null;
+        if (protectionParameter instanceof KeyStore.PasswordProtection) {
+            password = new String(((KeyStore.PasswordProtection) protectionParameter).getPassword());
+        }
+        // FIXME: decrytps it. probably should not?
+        X509Credential credential = new X509Credential(userKeyFilename, userCertFilename, password);
     }
 
 
-- 
1.6.3.2

